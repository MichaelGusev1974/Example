// Игра со случайными числами на основе операторов if
/*
С помощью метода Random.Next() мы имитируем бросок трех шестигранных игральных костей. Затем мы будем проверять 
получаемые значения для вычисления оценки. Если число очков больше заданной суммы, игроку отображается сообщение о выигрыше. 
В противном случае для пользователя будет выведено сообщение о проигрыше.

Если значения двух костей совпадают, вы получаете два премиальных балла за дубль.
Если значения трех костей совпадают, вы получаете шесть премиальных баллов за совпадение.
Если сумма всех трех костей и бонусов не меньше 15, вы выигрываете. В противном случае вы проиграли.
"Если при всех трех бросках костей выпало одно значение, вы получаете шесть бонусных очков".*/

/*Мы создадим новый экземпляр класса System.Random и сохраним ссылку на этот объект в переменной dice. Затем мы вызываем метод 
Random.Next() для объекта diceтри раза, указав как нижнюю, так и верхнюю границы для ограничения возможных значений между 1 и 6. 
Мы сохраняем три случайных числа в переменных roll1, roll2, а также roll3соответственно.
Далее мы суммируем три броска костей и сохраняем значение в переменной total.
Наконец, мы отображаем все значения, используя строковую интерполяцию.*/
Random dice = new Random();

int roll1 = dice.Next(1, 7);
int roll2 = dice.Next(1, 7);
int roll3 = dice.Next(1, 7);

int total = roll1 + roll2 + roll3;

Console.WriteLine($"Dice roll: {roll1} + {roll2} + {roll3} = {total}");

if ((roll1 == roll2) || (roll2 == roll3) || (roll1 == roll3))
{
    if ((roll1 == roll2) && (roll2 == roll3))
    {
        Console.WriteLine("You rolled triples!  +6 bonus to total!");
        total += 6;
    }
    else
    {
        Console.WriteLine("You rolled doubles!  +2 bonus to total!");
        total += 2;
    }
}
if (total >= 15)
{
    Console.WriteLine("You win!");
}

else
{
    Console.WriteLine("Sorry, you lose.");
}
/*Вызов различных типов методов в библиотеке классов .NET
Завершено
100 XP
8 минут
Мы вызываем методы с первых строк кода при использовании Console.WriteLine()метода. Не все классы и методы реализованы одинаково. В этом разделе будут рассмотрены некоторые из наиболее популярных вариантов, которые вам нужно будет понять при использовании методов из библиотеки классов .NET. Что еще более важно, вы узнаете, как найти и использовать документацию, чтобы лучше понять каждый метод.

Как вызывать методы в библиотеке классов .NET
Исходя из вашего предыдущего опыта работы с этим Console.WriteLine()методом, вы уже должны знать основы:

Начните с ввода имени класса, Console
Добавьте оператор доступа к элементу, .символ
Добавьте имя метода, WriteLine
Добавьте оператор вызова метода, который представляет собой набор круглых скобок ()
Наконец, добавьте значение, которое вы хотитеConsole.WriteLine(), чтобы метод выводил в качестве входного параметра между открывающей и закрывающей круглыми скобками (например, "Hello World!")
При необходимости, в зависимости от того, как разработчики разработали и внедрили данный метод, вам также может потребоваться:

Передайте дополнительные значения в качестве входных параметров
Принять возвращаемое значение
Мы рассмотрим входные параметры и возвращаемые значения в следующем разделе.

Хотя некоторые методы можно вызывать так же, как мы вызывали Console.WriteLine(), в библиотеке классов .NET есть другие методы, которые требуют другого подхода.

Вызов различных типов методов в библиотеке классов .NET
Следующий пример имитирует бросок кости, генерируя случайное число и выводя его на консоль:

C #

Копировать

Выполнить
Random dice = new Random();
int roll = dice.Next(1, 7);
Console.WriteLine(roll);
Если вы запускаете код несколько раз, в выводе консоли отображаются числа от 1 до 6.

Сначала давайте рассмотрим, что выполняет каждая строка кода, затем мы зададим несколько важных вопросов и сделаем несколько замечаний о работе с классами и методами в библиотеке классов .NET.

Первая строка кода создает новый экземпляр System.Randomкласса в библиотеке классов .NET и сохраняет ссылку на новый объект в переменной с именем dice.

Вторая строка кода вызывает метод diceобъектаNext(), передавая два параметра: минимальное и максимальное значение случайного числа. Next()Метод возвращает значение, которое мы сохраним в переменной с именем roll.

Третья строка кода вызывает WriteLine()метод для вывода значения rollна консоль.

В этом примере кода мы вызываем метод класса Random и класса Console. Однако способ, которым мы вызываем эти методы, отличается. Причина, по которой они вызываются с использованием другого метода, заключается в том, что некоторые методы имеют состояние, а другие не имеют состояния.

Методы с сохранением состояния и методы без состояния
В вычислительной технике состояние описывает состояние среды выполнения в определенный момент времени. Поскольку ваш код выполняется построчно, значения сохраняются в переменных. В любой момент во время выполнения текущее состояние приложения представляет собой совокупность всех значений, хранящихся в памяти.

Некоторые методы не полагаются на текущее состояние приложения для правильной работы. Другими словами, методы без состояния реализованы таким образом, что они могут работать без ссылки или изменения каких-либо значений, уже сохраненных в памяти. Методы без состояния также известны как статические методы.

Например, Console.WriteLine()метод не зависит от каких-либо значений, хранящихся в памяти. Он выполняет свою функцию и завершает работу, никоим образом не влияя на состояние приложения.

Однако другие методы должны иметь доступ к состоянию приложения для правильной работы. Другими словами, методы с отслеживанием состояния построены таким образом, что они полагаются на значения, сохраненные в памяти предыдущими строками кода, которые уже были выполнены, или они изменяют состояние приложения путем обновления значений или сохранения новых значений в памяти. Они также известны как методы экземпляра.

Методы с отслеживанием состояния (экземпляра) отслеживают свое состояние в полях, которые являются переменными, определенными в классе. Каждый новый экземпляр класса получает свою собственную копию тех полей, в которых хранится состояние.

Один класс может поддерживать как методы с сохранением состояния, так и методы без состояния. Однако, когда вам нужно вызвать методы с отслеживанием состояния, вы должны сначала создать экземпляр класса, чтобы метод мог получить доступ к состоянию.

Создание экземпляра класса
Экземпляр класса называется объектом. Чтобы создать новый экземпляр класса, вы будете использовать newоператор. Рассмотрим следующую строку кода, которая создает новый экземпляр Randomкласса для создания нового объекта с именемdice:

C #

Копировать
Random dice = new Random();
newОператор выполняет несколько важных действий:

Сначала он запрашивает адрес в памяти компьютера, достаточно большой, чтобы сохранить новый объект на основе Randomкласса.
Он создает новый объект и сохраняет его по адресу памяти.
Он возвращает адрес памяти, чтобы его можно было сохранить в diceпеременной.
С этого момента, когда на diceпеременную ссылаются, среда выполнения .NET выполняет поиск за кулисами, чтобы создать иллюзию, что вы работаете непосредственно с самим объектом.

Почему метод Next() отслеживает состояние?
Вам может быть интересно, почему Next()метод был реализован как метод с сохранением состояния? Не могли ли разработчики библиотеки классов .NET найти способ генерировать случайное число, не требуя состояния? И что именно хранится или на что ссылается Next()метод?

Это справедливые вопросы. На высоком уровне компьютеры хорошо выполняют конкретные инструкции для создания надежного и воспроизводимого результата. Чтобы создать иллюзию случайности, разработчики Next()метода решили фиксировать дату и время с точностью до доли миллисекунды и использовать это для заполнения алгоритма, который каждый раз выдает другое число. Хотя это не совсем случайно, этого достаточно для большинства приложений. Начальным значением является состояние, которое фиксируется и поддерживается в течение всего срока службы diceобъекта. Каждый последующий вызов Next()метода перезапускает алгоритм, но гарантирует, что начальное значение изменится так, что одно и то же значение не будет (обязательно) возвращено.

Однако, чтобы использовать этот Random.Next()метод, вам не обязательно понимать, как он работает. Важно знать, что некоторые методы требуют, чтобы вы создали экземпляр класса перед их вызовом, в то время как другие этого не делают.

Как вы можете определить, нужно ли создавать экземпляр класса перед вызовом его методов?
Один из способов узнать, как вызывать метод, - обратиться к документации. Вы найдете примеры, показывающие, должен ли метод вызываться из экземпляра объекта или непосредственно из класса.

 Примечание

Одна из наиболее полезных частей документации - это примеры кода, демонстрирующие, как использовать метод, который вы исследуете. Иногда вам нужно прокрутить страницу вниз, чтобы найти примеры кода.

Кроме того, вы можете попытаться получить доступ к методу непосредственно из самого класса. Худшее, что может случиться, это то, что вы получите ошибку компиляции.

Если вы введете следующую строку кода в .СЕТЕВОЙ редактор:

C #

Копировать

Выполнить
int result = Random.Next();
Появится красная волнистая линия, указывающая на ошибку компиляции. Наведя курсор мыши на красную волнистую линию, вы получите всплывающее окно со следующим сообщением:


Копировать

(1,14): error CS0120: An object reference is required for the non-static field, method, or property 'Random.Next()'
Резюме
Для вызова методов класса в библиотеке классов .NET вы будете использовать форматClassName.MethodName(), в котором .символ является оператором доступа к члену для доступа к методу, определенному в классе, а ()символы являются операторами вызова метода.
При вызове метода без состояния вам не нужно сначала создавать новый экземпляр его класса.
При вызове метода с отслеживанием состояния вам необходимо создать экземпляр класса и получить доступ к методу объекта.
Используйте newоператор для создания нового экземпляра класса.
Экземпляр класса называется объектом.*/